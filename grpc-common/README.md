# Cactus gRPC support

The standard Java classes generated by gRPC compiler (protoc plugin) do not fit the Scala well. Cactus adds support for mapping between both
client and server generated stubs and user-defined Scala traits.

## Client stub mapping

Protoc generates both blocking and asynchronous(streaming) stubs by default, however Cactus offers mapping for only the asynchronous one
(and currently doesn't support streaming either).

### Dependency
Gradle:
```groovy
compile "com.avast.cactus:cactus-grpc-client_2.12:VERSION"
```
SBT:
```scala
"com.avast.cactus" %% "cactus-grpc-client" % "VERSION"
```

### Usage

```proto
message TestApi {
    message GetRequest {
        repeated string names = 1;
    }
    
    message GetResponse {
        map<string, int32> results = 1;
    }
}

service MyService {
    rpc Get (TestApi.GetRequest) returns (TestApi.GetResponse) {}
}
```

The Scala trait:
```scala
import com.avast.cactus.grpc.ServerResponse
import scala.concurrent.Future

case class MyRequest(names: Seq[String])

case class MyResponse(results: Map[String, Int])

trait ClientTrait {
  def get(request: MyRequest): Future[ServerResponse[MyResponse]] // keep this format!
}
```

First, gRPC `Channel` has to be created (in standard way) and then a mapping method can be called on that channel:
```scala
import com.avast.cactus.grpc.client._ // this adds the `createMappedClient` method
import io.grpc.inprocess.InProcessChannelBuilder

val channel = InProcessChannelBuilder.forName("channelName").directExecutor.build // fine for testing

val client: ClientTrait = channel.createMappedClient[MyServiceFutureStub, ClientTrait](/* async interceptors go here */)
```

Notes:
* only asynchronous stub mappings are available (as stated above)
* The method in user-defined trait has to have this format: `def %name%(request: %Request%): Future[ServerResponse[%Response%]]`
(you don't have to use the `ServerResponse` which is just a type alias)
* For conversion between request/response case classes and GPB classes a standard Cactus functions will be used.
Currently you are not allowed to use GPB classes in the trait directly (the Cactus mapping will be used always).

### Client interceptors

There is also an option to use your own interceptors. gRPC offers only synchronous interceptors even for asynchronous stubs which may be
a very big complication for some advanced scenario. There is a `ClientAsyncInterceptor` trait for this.  
`ClientAsyncInterceptor` has one very common implementation provided by default - `ClientHeadersInterceptor`.
```scala
val client: ClientTrait = channel.createMappedClient[MyServiceFutureStub, ClientTrait](
  ClientHeadersInterceptor(Map("headerName" -> "headerValue"))
  // other interceptors may come here!
)
```

It's still possible to use standard gRPC interceptors via the `Channel` builder.

Read the [section below](#providing-own-interceptors) before developing your own interceptor.

## Server stub mapping

As with the [client mapping](#client-stub-mapping), you're supposed to create the server by a standard way, however the Cactus will help with
mapping with generated Java class to your trait.

### Dependency
Gradle:
```groovy
compile "com.avast.cactus:cactus-grpc-server_2.12:VERSION"
```
SBT:
```scala
"com.avast.cactus" %% "cactus-grpc-server" % "VERSION"
```

### Usage

```proto
message TestApi {
    message GetRequest {
        repeated string names = 1;
    }
    
    message GetResponse {
        map<string, int32> results = 1;
    }
}

service MyService {
    rpc Get (TestApi.GetRequest) returns (TestApi.GetResponse) {}
}
```

The Scala trait:
```scala
import io.grpc.Status
import scala.concurrent.Future

case class MyRequest(names: Seq[String])

case class MyResponse(results: Map[String, Int])

trait ServerTrait {
  def get(request: MyRequest): Future[Either[Status, MyResponse]]
}
```

Map the instance of `ServerTrait` to generated service stub:
```scala
import com.avast.cactus.grpc.server._  // this adds the `mappedToService` method

val impl: ServerTrait = ???

val service: io.grpc.ServerServiceDefinition = impl.mappedToService[MyServiceImplBase](/* async interceptors go here */)
```

Build the server in a standard way and add the service to it.

### Server interceptors

You can decorate the handler with two kinds of interceptors:
1. Asynchronous - instances of `ServerAsyncInterceptor` passed to the mapping function
1. Synchronous using the `ServerInterceptors.intercept` method (gRPC standard)

Read the [section below](#providing-own-interceptors) before developing your own interceptor.

### Providing context

gRPC has no option how to pass received headers to the handler by default - programmer must handle them in interceptors (and possibly
passing something into the handler through [Context](https://grpc.io/grpc-java/javadoc/io/grpc/Context.html)). Cactus provides context
mapping for the handler, e.g.
```scala
case class MyRequest(names: Seq[String])

case class MyResponse(results: Map[String, Int])

case class MyContextContent(i: Int, s: String)

case class MyContext(theHeader: String, content: MyContextContent)

trait MyApi {
  def get(request: MyRequest, ctx: MyContext): Future[Either[Status, MyResponse]]
}
```

Note the context class has to
* be a case class
* be a second parameter of the API method (name of the parameter is not important).

The `MyContext` instance is created by mapping incoming `Context` in following way:
```scala
val ctx = Context.current()

for {
  theHeader <- Option(ContextKeys.get[String]("theHeader").get(ctx))
  content <- Option(ContextKeys.get[MyContextContent]("content").get(ctx))
} yield {
  MyContext(theHeader, content)
}
```
1. `theHeader` is header received from the client. Headers are automatically passed to the `Context` to be available for this - no action required
   * Only `String` headers are supported
1. `content` is a case class inserted into the `Context` by an interceptor like this one:
    ```scala
    new ServerAsyncInterceptor {
      override def apply(m: GrpcMetadata): Future[Either[Status, GrpcMetadata]] = {
        val cont = MyContextContent(42, "jenda")
        
        Future.successful {
          Right(m.copy(context = m.context.withValue(ContextKeys.get[MyContextContent]("content"), cont)))
        }
      }
    }
    ```
Note that names and types of `MyContext` class fields have to match keys in `Context`. If some field is missing, an `INVALID_ARGUMENT` status is
returned to the client.

Read the [section below](#providing-own-interceptors) before developing your own interceptor.

## Providing own interceptors

gRPC has it's custom way to passing information between interceptors which is named [Context](https://grpc.io/grpc-java/javadoc/io/grpc/Context.html).
However that solution counts with using shared `Context.Key` on both sides (when putting in and getting out) which is not always possible.

The `ContextKeys` object was created to solve this. It contains static map with all keys which is shared across the whole JVM (context of a
single `ClassLoader` at least). **Use `ContextKeys.get[TheClass]("headers")` instead of `Context.key[TheClass]("headers")`.**
Note that keys in `Context` are considered as case-insensitive when using the `ContextconKeys` helper (this behavior is a standard in gRPC for headers).

Both `ClientAsyncInterceptor` and `ServerAsyncInterceptor` works the same way - it asynchronously converts `GrpcMetadata` (`Context` + `Metadata`)
to `Either[Status, GrpcMetadata]` thus you have a possibility to stop the request by returning `Left(Status)` in case something is going wrong
(e.g. some requirement is not fulfilled).
Use `Context` for passing anything between interceptors and `Metadata` for transferring headers.

On server side providing a _context_ to the handler is also possible. The context class is mapped to `Context` which comes to the handler 
(see [related section](#providing-context)). 
