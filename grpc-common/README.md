# Cactus gRPC support

The standard Java classes generated by gRPC compiler (protoc plugin) do not fit the Scala well. Cactus adds support for mapping between both
client and server generated stubs and user-defined Scala traits.

Both the server and client mapping are [Finally Tagless](https://www.beyondthelines.net/programming/introduction-to-tagless-final/)(use any
_`F[_]: Effect`_).

## Client stub mapping

Protoc generates both blocking and asynchronous(streaming) stubs by default, however Cactus offers mapping for only the asynchronous one
(and currently doesn't support streaming either).

### Dependency

Gradle:
```groovy
compile "com.avast.cactus:cactus-grpc-client_2.12:VERSION"
```
SBT:
```scala
"com.avast.cactus" %% "cactus-grpc-client" % "VERSION"
```

### Client usage

```proto
message TestApi {
    message GetRequest {
        repeated string names = 1;
    }
    
    message GetResponse {
        map<string, int32> results = 1;
    }
}

service MyService {
    rpc Get (TestApi.GetRequest) returns (TestApi.GetResponse) {}
}
```

The Scala trait:
```scala
import com.avast.cactus.grpc.ServerResponse

case class MyRequest(names: Seq[String])

case class MyResponse(results: Map[String, Int])

// choose your F! 
trait ClientTrait[F[_]] extends GrpcClient with AutoCloseable { // the trait may or may not extend AutoCloseable, see below
  def get(request: MyRequest): F[ServerResponse[MyResponse]] // keep this format (F[ServerResponse[MyResponse]])
}
```

First, gRPC `Channel` has to be created (in standard way) and then a mapping method can be called on that channel:
```scala
import com.avast.cactus.grpc.client._ // this adds the `createMappedClient` method
import io.grpc.inprocess.InProcessChannelBuilder
import monix.eval.Task

val channel = InProcessChannelBuilder.forName("channelName").directExecutor.build // fine for testing

val client: ClientTrait[Task] = channel.createMappedClient[MyServiceFutureStub, Task, ClientTrait](/* async interceptors go here */)
```

Notes:
* only asynchronous stub mappings are available (as stated above)
* The method in user-defined trait has to have this format: `def %name%(request: %Request%): F[ServerResponse[%Response%]]`
(you don't have to use the `ServerResponse` which is just a type alias)
* For conversion between request/response case classes and GPB classes a standard Cactus functions will be used.
Currently you are not allowed to use GPB classes in the trait directly (the Cactus mapping will be used always).

#### AutoCloseable client

It's recommended to specify your client trait to be `AutoCloseable`. However, to satisfy the dependency closeable channel has to be
provided at first place.  
Note: It should not cause troubles because all user-friendly factories provided by gRPC library return `io.grpc.ManagedChannel`
instance which satisfies the dependency. However, using just `io.grpc.Channel` together with `AutoCloseable` trait will cause compilation
to be aborted.

### Client interceptors

There is also an option to use your own interceptors. gRPC offers only synchronous interceptors even for asynchronous stubs which may be
a very big complication for some advanced scenario. There is a `ClientAsyncInterceptor` trait for this.  
`ClientAsyncInterceptor` has one very common implementation provided by default - `ClientHeadersInterceptor`.
```scala
val client: ClientTrait[Task] = channel.createMappedClient[MyServiceFutureStub, Task, ClientTrait](
  ClientHeadersInterceptor(Map("headerName" -> "headerValue"))
  // other interceptors may come here!
)
```

It's still possible to use standard gRPC interceptors via the `Channel` builder.

Read the [section below](#providing-own-interceptors) before developing your own interceptor.

## Server stub mapping

As with the [client mapping](#client-stub-mapping), you're supposed to create the server by a standard way, however the Cactus will help with
mapping with generated Java class to your trait.

### Dependency
Gradle:
```groovy
compile "com.avast.cactus:cactus-grpc-server_2.12:VERSION"
```
SBT:
```scala
"com.avast.cactus" %% "cactus-grpc-server" % "VERSION"
```

### Server usage

```proto
message TestApi {
    message GetRequest {
        repeated string names = 1;
    }
    
    message GetResponse {
        map<string, int32> results = 1;
    }
}

service MyService {
    rpc Get (TestApi.GetRequest) returns (TestApi.GetResponse) {}
}
```

The Scala trait:
```scala
import com.avast.cactus.grpc._
import io.grpc.Status

case class MyRequest(names: Seq[String])

case class MyResponse(results: Map[String, Int])

trait ServerTrait[F[_]] extends GrpcService {
  def get(request: MyRequest): F[Either[Status, MyResponse]]
}
```

Map the instance of `ServerTrait` to generated service stub:
```scala
import monix.eval.Task
import com.avast.cactus.grpc.server._  // this adds the `mappedToService` method

val impl: ServerTrait[Task] = ???

val service: io.grpc.ServerServiceDefinition = impl.mappedToService[MyServiceImplBase](/* async interceptors go here */)
```

Build the server in a standard way and add the service to it.

### Server interceptors

You can decorate the handler with two kinds of interceptors:
1. Asynchronous - instances of `ServerAsyncInterceptor` passed to the mapping function
1. Synchronous using the `ServerInterceptors.intercept` method (gRPC standard)

Read the [section below](#providing-own-interceptors) before developing your own interceptor.

### Providing context

gRPC has no option how to pass received headers to the handler by default - programmer must handle them in interceptors (and possibly
passing something into the handler through [Context](https://grpc.io/grpc-java/javadoc/io/grpc/Context.html)). Cactus however provides context
mapping for the handler, e.g.
```scala
case class MyRequest(names: Seq[String])

case class MyResponse(results: Map[String, Int])

case class MyContext(theHeader: String)

trait MyApi[F[_]] extends GrpcService {
  def get(request: MyRequest, ctx: MyContext): F[Either[Status, MyResponse]]
}
```

Note the context class has to
* be a case class
* be a second parameter of the API method (name of the parameter is not important).

The `MyContext` instance is created automatically by mapping incoming `Context` in following way:
```scala
val ctx = Context.current()

for {
  theHeader <- Option(ContextKeys.get[String]("theHeader").get(ctx))
} yield {
  MyContext(theHeader, content)
}
```
where `theHeader` is header received from the client. Headers are automatically passed to the `Context` to be available for this - no action
is required. Please only `String` headers are supported (gRPC limitation).

#### Custom class in context

There are scenarios where you need to take a header and transform it to some more complex context class (e.g. authentication/authorization).
You have to provide your own interceptor doing the transformation however the mapping to the context class is very similar to the case with
a header:

```scala
case class MyContextContent(i: Int, s: String)

case class MyContext(theHeader: String, content: MyContextContent)

...

val ctx = Context.current()

for {
  theHeader <- Option(ContextKeys.get[String]("theHeader").get(ctx))
  content <- Option(ContextKeys.get[MyContextContent]("content").get(ctx))
} yield {
  MyContext(theHeader, content)
}
```
1. `theHeader` is header received from the client. Headers are automatically passed to the `Context` to be available for this - no action required
   * Only `String` headers are supported
1. `content` is a case class inserted into the `Context` by an interceptor like this one:
    ```scala
    new ServerAsyncInterceptor[Task] {
      override def apply(m: GrpcMetadata): Task[Either[Status, GrpcMetadata]] = {
        val cont = MyContextContent(42, "jenda")
        
        Task.now {
          Right(m.copy(context = m.context.withValue(ContextKeys.get[MyContextContent]("content"), cont)))
        }
      }
    }
    ```
Note that names and types of `MyContext` class fields have to match keys in `Context`. If some field is missing, an `INVALID_ARGUMENT` status is
returned to the client.

Read the [section below](#providing-own-interceptors) before developing your own interceptor.

## Providing own interceptors

gRPC has it's custom way to passing information between interceptors which is named [Context](https://grpc.io/grpc-java/javadoc/io/grpc/Context.html).
However that solution counts with using shared `Context.Key` on both sides (when putting in and getting out) which is not always possible.

The `ContextKeys` object was created to solve this. It contains static map with all keys which is shared across the whole JVM (context of a
single `ClassLoader` at least). **Use `ContextKeys.get[TheClass]("headers")` instead of `Context.key[TheClass]("headers")`.**
Note that keys in `Context` are considered as case-insensitive when using the `ContextconKeys` helper (this behavior is a standard in gRPC for headers).

Both `ClientAsyncInterceptor` and `ServerAsyncInterceptor` works the same way - it asynchronously converts `GrpcMetadata` (`Context` + `Metadata`)
to `Either[Status, GrpcMetadata]` thus you have a possibility to stop the request by returning `Left(Status)` in case something is going wrong
(e.g. some requirement is not fulfilled).
Use `Context` for passing anything between interceptors and `Metadata` for transferring headers.

On server side providing a _context_ to the handler is also possible. The context class is mapped to `Context` which comes to the handler 
(see [related section](#providing-context)). 
